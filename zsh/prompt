# Adapted from github.com/bitprophet/dotfiles

#
# Colorized prompt, with different username colors for different systems.
#

# My specific palette, using zsh's builtin color expansions
typeset -A PALETTE C # Force zsh to treat as an array
PALETTE=(
    blue    33
    cyan    51
    green   82
    purple  171
    red     160
    yellow  227
)

# Wrap in %F{} and use short array name
for key in ${(k)PALETTE}; do
    C[$key]="%F{$PALETTE[$key]}"
done

# System => color/hostname map:
#   USER: username color
#   CWD: location/cwd color
#   HOST: hostname display
# Defaults:
# USER=$C[green]
# CWD=$C[blue]

# Manually cut hostname; hostname -s bails out on some systems.
HOST=`hostname | cut -d '.' -f 1`
DOMAIN=`hostname | cut -d '.' -f 2-`

# Themed by domain name
case $DOMAIN in
    # Personal production
    #bitprophet.org | fabfile.org ) USER=$C[cyan] ;;
    # Work production
    #whiskeymedia.com | giantbomb.com | comicvine.com \
    #| tested.com | screened.com | animevice.com) USER=$C[red] ;;
esac

# Themed by host/node name (takes precedence over domain)
# case $HOST in
#     # Workstations
#     alex-debian ) USER=$C[red] CWD=$C[green] ;;
# esac


function shortpath() {
    # Special vim-tab-like shortpath (~/folder/directory/foo => ~/f/d/foo)
    _pwd=`pwd | sed "s#$HOME#~#"`
    if [[ $_pwd == "~" ]]; then
        _dirname=$_pwd
    else
        _dirname=`dirname "$_pwd" | sed -r "s/\/(.)[^\/]*/\/\1/g"`
        if [[ $_dirname == "/" ]]; then
            _dirname=""
        fi
        _dirname="$_dirname/`basename "$_pwd"`"
    fi
    echo "${_dirname}"
}

function virtualenv_() {
    # Python virtualenv
    _venv=`basename "$VIRTUAL_ENV"`
    venv="" # need this to clear it when we leave a venv
    if [[ -n $_venv ]]; then
        venv=$_venv
    fi

    # RVM (steals the venv slot if there's no venv)
    if [[ -s $_rvm && -z $_venv ]]; then
        # Just show Ruby gemset.  I don't use different interpreter lines, nor
        # do I care about patchlevel.
        #_venv=`$_rvm_home/bin/rvm-prompt g`
        if [[ "$_venv" != "system" && -n $_venv ]]; then
            venv=$_venv
        fi
    fi

    if [[ -n "$venv" ]]; then
        echo "$venv"
    else
        echo - -
    fi
}

function git_status() {
    _branch=$(git symbolic-ref HEAD 2>/dev/null)
    current_git_branch=${_branch#refs/heads/}
}

function dirty() {
    git_status
    # Print nothing if not in a git repo
    [[ -z $current_git_branch ]] && return

    # Git branch / dirtiness
    # Dirtiness cribbed from:
    # http://henrik.nyh.se/2008/12/git-dirty-prompt#comment-8325834
    _dirty="*"
    if git update-index -q --refresh &>/dev/null; git diff-index --quiet --cached HEAD --ignore-submodules -- 2>/dev/null && git diff-files --quiet --ignore-submodules 2>/dev/null
        then _dirty=""
    fi
    echo $_dirty
}

function branch() {
    git_status
    if [[ -n "$current_git_branch" ]]; then
        echo "$current_git_branch"
    else
        echo - -
    fi
}

function displayhost() {
    # %m/%M seem broken for me? :(
    echo "$(hostname)"
}

#
# Prompt itself
#

function prompt_orig() {
    # [<green>time</green>] <USER>HOST</USER>:<CWD>pwd</CWD>
    #     {<magenta>venv</magenta>} [<magenta>branch</magenta>] <CWD>end</CWD>
    time="[$C[green]%T%f]"
    hostname="${USER}$(displayhost)%f"
    _path="${CWD}$(shortpath)%f"
    end="${CWD}»%f"
    export PS1="${time} ${hostname}:${_path} {$C[purple]$(virtualenv_)%f} [$C[purple]$(branch)$C[red]$(dirty)%f] ${end} "
}

# Which character to use to signify repository status
function repo_char {
    git branch > /dev/null 2>/dev/null && echo '±' && return
    echo 'o'
}

function virtualenv_info {
    [ $VIRTUAL_ENV ] && echo '('$(basename $VIRTUAL_ENV)')'
}

ZSH_THEME_GIT_PROMPT_PREFIX=" on %{$fg[magenta]%}"
ZSH_THEME_GIT_PROMPT_SUFFIX="%{$reset_color%}"
ZSH_THEME_GIT_PROMPT_DIRTY="%{$fg[green]%}!"
ZSH_THEME_GIT_PROMPT_UNTRACKED="%{$fg[green]%}?"
ZSH_THEME_GIT_PROMPT_CLEAN=""

# get the name of the branch we are on
function git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
}

# Checks if working tree is dirty
parse_git_dirty() {
  local SUBMODULE_SYNTAX=''
  if [[ $POST_1_7_2_GIT -gt 0 ]]; then
        SUBMODULE_SYNTAX="--ignore-submodules=dirty"
  fi
  if [[ -n $(git status -s ${SUBMODULE_SYNTAX}  2> /dev/null) ]]; then
    echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
  else
    echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
  fi
}

function prompt_new {
    autoload colors zsh/terminfo
    colors

    setopt prompt_subst

    PROMPT='
%{$fg[magenta]%}%n%{$reset_color%} at %{$fg[yellow]%}%m%{$reset_color%} in %{$fg_bold[green]%}${PWD/#$HOME/~}%{$reset_color%}$(git_prompt_info)
$(virtualenv_info)$(repo_char) '

    RPROMPT='$(date "+%x %T %Z")'

}

function precmd() {
    prompt_new
}
